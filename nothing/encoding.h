/*
 * Copyright (C) 2021-2022 John Hunter Kohler <jhunterkohler@gmail.com>
 */
#ifndef NOTHING_ENCODING_H_
#define NOTHING_ENCODING_H_

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <concepts>
#include <string_view>
#include <ranges>

namespace nothing {

template <class I>
concept input_string_iterator = std::input_iterator<I> &&
    std::indirectly_copyable<I, char *>;

template <class R>
concept input_string_range = std::ranges::range<R> &&
    input_string_iterator<std::ranges::iterator_t<R>>;

template <class I>
concept input_byte_iterator = std::input_iterator<I> &&
    std::indirectly_copyable<I, uint8_t *>;

template <class R>
concept input_byte_range = std::ranges::range<R> &&
    input_byte_iterator<std::ranges::iterator_t<R>>;

enum class hex_mode {
    upper,
    lower,
};

namespace detail {

template <hex_mode Mode>
inline constexpr std::string_view hex_charset =
    Mode == hex_mode::upper ? "0123456789ABCDEF" : "0123456789abcdef";

inline constexpr uint8_t hex_values[256]{
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
};

} // namespace detail

template <hex_mode Mode = hex_mode::upper, std::output_iterator<char> O>
constexpr auto hex_encode(uint8_t value, O dest)
{
    constexpr auto charset = detail::hex_charset<Mode>;

    *dest++ = charset[value >> 4];
    *dest++ = charset[value & 15];

    return dest;
}

// clang-format off

template <hex_mode Mode = hex_mode::upper, input_byte_iterator I,
          std::sentinel_for<I> S, std::output_iterator<char> O>
constexpr std::ranges::in_out_result<I, O> hex_encode(I first, S last, O dest)
{
    for (; first != last; ++first) {
        uint8_t value = *first;
        dest = hex_encode<Mode>(value, dest);
    }

    return { first, dest };
}

template <hex_mode Mode = hex_mode::upper, input_byte_range R,
          std::output_iterator<char> O>
constexpr std::ranges::in_out_result<std::ranges::borrowed_iterator_t<R>, O>
hex_encode(R &&r, O dest)
{
    return hex_encode<Mode>(
        std::ranges::begin(r), std::ranges::end(r), std::move(dest));
}

constexpr uint8_t hex_decode(char c)
{
    return detail::hex_values[(unsigned char)c];
}

template <input_string_iterator I, std::sentinel_for<I> S,
          std::output_iterator<uint8_t> O>
constexpr std::ranges::in_out_result<I, O> hex_decode(I first, S last, O dest)
{
    while(first != last) {
        uint8_t a = hex_decode(*first++);
        uint8_t b = first != last ? hex_decode(*first++) : 0;

        if(a > 15  || b > 15) {
            throw std::invalid_argument(
                "nothing::hex_decode: Invalid hex input");
        }

        *dest++ = (a << 4) | b;
    }

    return { first, dest };
}

template <input_string_range R, std::output_iterator<uint8_t> O>
constexpr std::ranges::in_out_result<std::ranges::borrowed_iterator_t<R>, O>
hex_decode(R &&r, O dest)
{
    return hex_decode(
        std::ranges::begin(r), std::ranges::end(r), std::move(dest));
}

enum class base64_mode {
    regular,
    url,
};

enum class base64_padding {
    required,
    optional,
    none,
};

namespace detail {

template <base64_mode Mode>
inline constexpr std::string_view base64_charset =
    Mode == base64_mode::regular ?
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" :
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

inline constexpr uint8_t base64_values[256]{
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0x3F,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
    0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24,
    0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
    0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
};

inline constexpr uint8_t base64url_values[256]{
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
    0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
    0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24,
    0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
    0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
};

class base64_decode_error : public std::invalid_argument {
    const char* what() const noexcept override
    {
        return "nothing::base64_decode: Invalid base64 input";
    }
};

} // namespace detail

template <base64_mode Mode = base64_mode::regular,
          base64_padding Padding = base64_padding::optional,
          input_byte_iterator I, std::sentinel_for<I> S,
          std::output_iterator<char> O>
constexpr std::ranges::in_out_result<I, O>
base64_encode(I first, S last, O dest)
{
    constexpr auto charset = detail::base64_charset<Mode>;
    constexpr auto padding = Padding != base64_padding::none;

    for(; first != last ;) {
        uint8_t a = *first++;

        if(first == last) {
            *dest++ = charset[a >> 2];
            *dest++ = charset[(a & 0x3) << 4];

            if constexpr (padding) {
                *dest++ = '=';
                *dest++ = '=';
            }

            break;
        }

        uint8_t b = *first++;

        if(first == last) {
            *dest++ = charset[a >> 2];
            *dest++ = charset[(a & 0x3) << 4 | b >> 4];
            *dest++ = charset[(b & 0xF) << 2];

            if constexpr (padding) {
                *dest++ = '=';
            }

            break;
        }

        uint8_t c = *first++;
        *dest++ = charset[a >> 2];
        *dest++ = charset[(a & 0x3) << 4 | b >> 4];
        *dest++ = charset[(b & 0xF) << 2 | c >> 6];
        *dest++ = charset[c & 0x3F];
    }

    return { first, dest };
}

template <base64_mode Mode = base64_mode::regular,
          base64_padding Padding = base64_padding::optional,
          input_byte_range R, std::output_iterator<char> O>
constexpr std::ranges::in_out_result<std::ranges::borrowed_iterator_t<R>, O>
base64_encode(R &&r, O dest)
{
    return base64_encode<Mode, Padding>(
        std::ranges::begin(r), std::ranges::end(r), std::move(dest));
}

template <base64_mode Mode = base64_mode::regular,
          base64_padding Padding = base64_padding::optional,
          input_string_iterator I, std::sentinel_for<I> S,
          std::output_iterator<uint8_t> O>
constexpr std::ranges::in_out_result<I, O>
base64_decode(I first, S last, O dest);

template <base64_mode Mode = base64_mode::regular,
          base64_padding Padding = base64_padding::optional,
          input_string_range R, std::output_iterator<uint8_t> O>
constexpr std::ranges::in_out_result<std::ranges::borrowed_iterator_t<R>, O>
base64_decode(R &&r, O dest)
{
    return base64_decode<Mode, Padding>(
        std::ranges::begin(r), std::ranges::end(r), std::move(dest));
}

// clang-format on

} // namespace nothing

#endif
